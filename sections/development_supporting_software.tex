%!TEX root = ../Project.tex

\subsection{Supporting software}

In addition to the framework chosen in the previous section, there is a range
of other software available to facilitate the creation of web applications.

\subsubsection{Spring Roo}

Spring Roo is a \gls{rad} tool created by SpringSource (the Spring development
team) to aid developers in creating Java web applications. It works by
providing an executable, \texttt{roo}, which generates ``application
scaffolding'' programmatically. For example, inside Roo it is possible to run
several commands to set up a basic Spring application:

\begin{lstlisting}
project --topLevelPackage uk.ac.york.module_allocation
persistence setup --database MYSQL --provider HIBERNATE
entity --class ~.domain.Student
field string --fieldName username
\end{lstlisting}

These four lines of code generate a Java class representing a student complete
with setters and getters, 500 lines of XML configuration files and 20 lines of
application property files. It is also possible to generate a simple
\gls{crud} interface for displaying and modifying data in the browser, using
the \texttt{web mvc scaffold} command.

It is possible to tell from inspection that the code generated by Roo is not
as perfect as that which could be crafted by an expert Java developer -- as
might be expected from a code generation tool, there is some unnecessary
repetition. The large amount of code generated results in a codebase that
feels fairly bloated and a compiled \gls{war} file that is larger than
necessary, but the advantage is an application that is set up in just moments.
As the generation tool is written by the Spring developers, one can be assured
that the code generated conforms to the basic standards of Spring.

When considering using a generation tool such as Roo, one must think about the
lock-in that it entails. However, Chapter 6 of the Roo reference documentation
\cite{RooReferenceDocs2011} is titled ``Removing Roo''. In it, the authors
note that a key part of the Roo mission statement was ``without compromising
engineering integrity or flexibility''. The developers provide a simple,
three-step guide to removing Roo from any project. If the future maintainers
of this software require that it not include Roo, it will be easy to remove.
The benefits that Roo provides in the short-term far outweigh the negatives
that might be incurred by needing to remove it.

\subsubsection{Templating engines}

There are many different engines that can be used as components of a Java (in
this case, Spring) project to generate the view that is displayed to the
end-user. Generating this view is commonly referred to as `templating'.
Examples of commonly-used Java templating languages and software include
\gls{jsp}, Tiles and Freemarker.

% Plain old JSP

\gls{jsp} is a common language that is also used in Tiles. \gls{jsp} can be
used at a basic level to include dynamic elements in \gls{html}. The following
is an example of a \texttt{.jsp} file that outputs \gls{html} to the client:

\begin{lstlisting}[language=HTML]
<html>
  <h1>Welcome to the module allocation system, ${studentname}!</h1>
</html>
\end{lstlisting}

% Apache Tiles

Apache Tiles improves upon just using \gls{jsp} markup by itself and provides
other useful functions. Templates are written in the same language, but
developers can define `fragments' which are assembled when the page is
requested. The fragments (or tiles, which is where the software gets its name)
can be used to build up a page from several different parts. For example, it
is possible to define fragments for the page header and footer and left-hand
navigation menu, to ensure they are identical across the application. A
template file may resemble the following, where \texttt{header.jsp} and
\texttt{footer.jsp} are files that contain the site header and footer
respectively:

\begin{lstlisting}[language=HTML]
<html>
  <tiles:insertTemplate path="/common/header.jsp" />
  <div id="container">
    <h1>This is the actual page content.</h1>
  </div>
  <tiles:insertTemplate path="/common/footer.jsp" />
</html>
\end{lstlisting}

% Freemarker

Freemarker is another templating engine that is more complex than Tiles, but
at the expense of not enforcing complete separation between model and view --
this means that business logic may be found in the front-end of the
application, something which is considered bad in \gls{mvc} web development.
The following code demonstrates this, for example through the use of iterators
and conditionals:

\begin{lstlisting}[language=HTML]
<html>
  <#include "header.ftl" />
  <h1>Welcome to the module allocation system, ${student_name}!</h1>
  <p>These are the modules you have been allocated:</p>
  <ul>
  <#list modules as m>
    <li <#if m.level == "hard">class="hard"</#if>>${m.name} (${m.code})</li>
  </#list>
  </ul>
</html>
\end{lstlisting}

In his paper on enforcing separation between the model and the view, Parr
\cite{Parr2004templateengines} ranks Freemarker very poorly. Parr has also
created his own templating engine, named StringTemplate, that strictly
enforces separation between the model and the view. His paper articulates
clearly why enforcing the separation between model and view is a positive for
a web application, and his argument is convincing. As would be expected, his
software is uncompromising about applying the constraints he argues in favour
of in his paper.

This application will use Apache Tiles, as it is the engine that Spring (and
Spring Roo) implements by default when scaffolding a basic web application.
However, that is not to say that Tiles is the best option, it is simply the
most practical for this application. The front-end code will ideally not be
tightly coupled to the controller or model, resulting in it being
straightforward to swap out the templating engine in the future.
